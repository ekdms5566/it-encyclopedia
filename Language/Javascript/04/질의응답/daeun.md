# 4주차 질의응답 (딥다이브 23장-26장)

<br>

## 23. 실행 컨텍스트

---

1. 소스코드의 타입에 대해 설명해주세요.

- 소스코드의 타입으로는 전역에 존재하는 소스코드인 전역 코드와 함수 내부에 존재하는 소스코드인 함수 코드와 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드인 eval 코드와 모듈 내부에 존재하는 소스코드인 모듈코드가 있습니다.

2. 실행 컨텍스트 생성 과정에 대해 설명해주세요.

- 실행 컨텍스트는 전역 컨텍스트를 먼저 생성한 후, 함수 호출 시마다 함수 단위로 컨텍스트가 생성됩니다. 먼저 전역 코드에 진입하여 전역 객체가 생성되며, 전역 실행 컨텍스트가 생성된 후 실행 컨텍스트에 스택이 쌓이며 스코프 체인 생성과 초기화, 변수 객체화, this 바인딩 값 결정을 순차적으로 실행합니다. 이는 프로그램 실행을 위한 준비며 다음으로는 전역 코드를 실행합니다. 전역 코드를 실행하여 변수 값 할당 또는 함수 호출 등을 실행합니다.

3. 실행 컨텍스트에 대해 말해보세요

- 실행 컨텍스트는 실행할 코드에 제공할 환경 정보를 모아놓은 객체라고 할 수 있으며, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 요소이기도 합니다. 자바스크립트는 실행 컨텍스트가 활성화되는 시점에 호이스팅, this 값 설정을 실행하게 됩니다.

4. 식별자 검색 과정에 대해 설명해주세요.

- 식별자를 검색할 때는 제일 먼저 실행 중인 실행 컨텍스트에서 식별자를 검색합니다. 이 때 선언된 식별자는 실행 컨텍스트의 렉시컬 환경의 환경 레코드에 등록되어 있으며, 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경인 상위 스코프로 이동하여 식별자를 검색합니다.

5. 실행컨텍스트 를 활용하여, var로 선언된 변수가 어떻게 호이스팅되는지 설명해주세요.

- 자바스크립트는 가장 먼저 전역 실행 컨텍스트를 생성해서 콜 스택에 넣은 후, 전체 코드를 스캔하는데 이 때 선언한 식별자 변수가 var 키워드로 선언되었을 경우 undefined로 값을 할당하여 환경 레코드에 기록하며 이 과정을 호이스팅이 발생한다고 합니다.

<br>

## 24. 클로저

---

1. 클로저에 대해서 설명해주세요.

- 외부 함수 호출이 종료되더라도 외부 함수의 지역 변수 및 변수 스코프 객체의 체인 관계를 유지할 수 있는 구조를 클로저라고 합니다. 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경인 스코프를 기억하여 자신이 선언됐을 때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수를 의미합니다.

2. 캡슐화를 정보 은닉 개념과 함께 설명해주세요.

- 캡슐화는 객체지향 패러다임 중 하나로 중요한 데이터를 보호하는 것을 의미하며 일반적으로 연관있는 변수와 함수를 묶는 작업을 말하기도 합니다. 캡슐화를 할 경우 내부의 속성이나 메서드를 외부에 노출하지 않기 때문에 자연스럽게 정보가 은폐되어지며 직접 접근이 허용되지 않기 때문에 정보 은닉이 가능합니다.

3. 클로저를 사용하는 이유는 무엇인가요?

- 클로저 함수는 외부 함수의 실행이 끝나더라도 외부 함수 내 변수를 사용할 수 있으며 특정 데이터를 스코프 안에 가둔 채로 계속 사용할 수 있게 하는 폐쇄성을 가지며, 캡슐화하는 것이 가능하기 때문에 정보에 직접 접근하는 것을 제한할 수 있습니다. 또한 클로저 함수를 변수에 할당하여 사용하면 독립적으로 값을 사용하고 보존할 수 있기 때문에 모듈화에 유리합니다.

4. 클로저를 어떻게 생성하나요?

- 클로저는 외부 함수에 내부 함수인 클로저를 선언하고 내부 함수를 반환하는 형태로 생성할 수 있습니다.

5. 클로저의 장점과 단점에 대해 설명해주세요.

- 클로저는 전역 변수 사용을 억제할 수 있으며, 캡슐화가 가능하여 정보 은닉을 할 수 있다는 장점이 있지만 메모리 소비하며 스코프를 생성하고 변수를 조회할 때마다 클로저로 생성한 스코프를 탐색해야한다는 문제가 있습니다.

<br>

## 25. 클래스

---

1. 클래스와 함수 생성자의 차이점은 무엇인가요?

- 함수 생성자는 호이스팅이 되지만 클래스는 호이스팅이 되지 않습니다. 클래스로 선언하기 전 접근할 경우 레퍼런스 에러를 출력합니다.

2. 정적 메서드와 프로토타입 메서드의 차이점은 무엇인가요?

- 정적 메소드는 인스턴스의 프로토타입 체인에 속해있지 않기 때문에 인스턴스의 프로퍼티를 참조하지 않으며 클래스로 호출이 가능하지만 프로토타입 메소드는 인스턴스로 호출하며 인스턴스의 프로퍼티를 참조할 수 있다는 차이점이 있습니다.

3. 클래스의 상속에 대해서 말해보세요

- 클래스 상속을 사용하면 클래스를 다른 클래스로 확장하는 것이 가능하며 extends 키워드를 통해 구현할 수 있습니다. 클래스 상속을 통해 재사용성을 높일 수 있으며, 상속을 통해 새로운 클래스를 생성하여 기존 클래스를 확장시키면 유지보수에도 용이하다는 장점이 있습니다.

4. 클래스의 정의에 대해 설명해주세요.

- 클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의한 것으로 자바스크립트에서는 ES6에서 추가된 새로운 문법입니다. 인스턴스를 생성하고 클래스 필드를 초기화하기 위해 특수한 메소드인 constructor를 사용하여 클래스를 선언합니다.

5. 정적 클래스 멤버를 만드는 이유는 무엇인가요?

- 정적 클래스 멤버는 클래스의 모든 객체가 공유하는 멤버를 의미하며 해당 클래스의 모든 객체에 대해 하나의 데이터만 유지하는 것이 가능하기 때문에 사용합니다.

<br>

## 26. ES6 함수의 추가 기능

---

1. 화살표 함수와 일반 함수의 차이를 설명해주세요.

- 1. this
  - 일반 함수 : 함수 호출 방식에 따라 this에 바인딩할 객체가 동적으로 결정된다.
  - 화살표 함수 : 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되며, 언제나 상위 스코프의 this를 가리킨다.
- 2. 생성자 함수로 사용 가능 여부
  - 일반 함수는 생성자 함수로 사용할 수 있다.
  - prototype 프로퍼티를 가지고 있지 않기 때문에 화살표 함수는 생성자 함수로 사용할 수 없다.
- 3. arguments 사용 가능 여부
  - 일반 함수에서는 함수가 실행될 때 암묵적으로 arguments 변수가 전달되어 사용할 수 있다.
  - 화살표 함수에서는 arguments 변수가 전달되지 않는다.

2. 매개변수 기본값에 대해 설명해주세요.

- 매개변수 기본값을 사용하면 값이 전달되지 않은 함수 파라미터의 기본값을 설정하는 것이 가능합니다. 함수에서 매개 변수가 제공되지 않은 경우 지정한 기본값이 컴파일러에 의해 적용됩니다.

3. ES6의 메서드에 대해 설명해주세요.

- ES5에서 메소드를 선언하려면 프로퍼티 값으로 함수 선언식을 할당했지만 ES6에서의 메소드는 메소드 축약 표현으로 정의된 함수라고 정의되었으며, 메소드 선언 시 function 키워드를 생략한 축약 표현으로 사용하며 인스턴스를 생성할 수 없는 non-constructor입니다. 또한 ES6의 메소드는 자신을 바인딩한 객체를 내부 슬롯 [[HomeObject]]로 가지며 이를 통해 super 키워드 사용이 가능합니다.

4. Rest 파라미터에 대해 설명해주세요.

- Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는 매개변수를 의미합니다. Rest 파라미터는 먼저 선언된 파라미터에 할당된 인수를 제외한 나머지 인수들이 모두 배열에 담겨 할당되며 반드시 마지막 파라미터여야 합니다. 또한 함수 객체의 length 프로퍼티에 영향을 미치지 않는다는 특징을 가지고 있습니다.

5. Map 오브젝트에 대해 설명해주세요.

- Map 오브젝트는 key, vlaue 형태를 띄며 기존 객체와는 다르게 메소드를 사용하여 삽입, 조회, 삭제가 가능하여 객체보다 동작과 의도를 정확하게 보여줍니다. 또한 문자열이 아닌 값도 키로 사용 가능하다는 장점을 가지고 있으며 객체의 프로퍼티를 자주 변경해야할 때 편리하게 사용이 가능합니다.
